import { expect } from "chai";
import { ethers, upgrades } from "hardhat";
import { Contract } from "ethers";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";

describe("TrustlessTeamProtocol", function () {
  let userRegister: any;
  let reputation: any;
  let employeeAssignment: any;
  let systemWallet: any;
  let owner: HardhatEthersSigner;
  let user1: HardhatEthersSigner;
  let user2: HardhatEthersSigner;
  let employee1: HardhatEthersSigner;

  beforeEach(async function () {
    [owner, user1, user2, employee1] = await ethers.getSigners();

    try {
      // Deploy Employee Assignment first
      const EmployeeAssignmentFactory = await ethers.getContractFactory("EmployeeAssignment", owner);
      employeeAssignment = await upgrades.deployProxy(EmployeeAssignmentFactory, [], {
        initializer: "__EmployeeAssignment_init",
        kind: "uups"
      });
      await employeeAssignment.waitForDeployment();
      const employeeAssignmentAddress = await employeeAssignment.getAddress();

      // Deploy System Wallet with Employee Assignment address
      const SystemWalletFactory = await ethers.getContractFactory("System_wallet", owner);
      systemWallet = await upgrades.deployProxy(SystemWalletFactory, [employeeAssignmentAddress], {
        initializer: "initialize",
        kind: "uups"
      });
      await systemWallet.waitForDeployment();
      const systemWalletAddress = await systemWallet.getAddress();

      // Deploy UserRegister as registry
      const UserRegisterFactory = await ethers.getContractFactory("UserRegister", owner);
      userRegister = await upgrades.deployProxy(UserRegisterFactory, [
        employeeAssignmentAddress,
        systemWalletAddress
      ], {
        initializer: "initialize",
        kind: "uups"
      });
      await userRegister.waitForDeployment();
      const userRegisterAddress = await userRegister.getAddress();

      // Deploy TrustlessTeamProtocol (main contract) with all dependencies
      const MainContractFactory = await ethers.getContractFactory("TrustlessTeamProtocol", owner);
      reputation = await upgrades.deployProxy(MainContractFactory, [
        employeeAssignmentAddress,  // _employeeAssignment
        24,                        // _cooldownInHour
        1000,                     // _maxStake
        systemWalletAddress,      // _systemWallet
        userRegisterAddress,      // _userRegistry
        10,                       // _NegPenalty
        48                        // _minRevisionTime
      ], {
        initializer: "initialize",
        kind: "uups"
      });
      await reputation.waitForDeployment();
    } catch (error) {
      console.error("Error during deployment:", error);
      throw error;
    }
  });

  describe("UserRegister", function () {
    it("Should allow user registration", async function () {
      await userRegister.connect(user1).register(
        "User One",
        25
      );

      const userData = await userRegister.getMyData();
      expect(userData.isRegistered).to.be.true;
      expect(userData.name).to.equal("User One");
      expect(userData.age).to.equal(25);
    });

    it("Should prevent duplicate registration", async function () {
      await userRegister.connect(user1).register(
        "User One",
        25
      );

      await expect(
        userRegister.connect(user1).register(
          "User One Again",
          25
        )
      ).to.be.revertedWith("Err: Already registered");
    });
  });

  describe("EmployeeAssignment", function () {
    it("Should allow owner to add employee", async function () {
      await employeeAssignment.connect(owner).assignNewEmployee(employee1.address);
      const isEmployee = await employeeAssignment.employees(employee1.address);
      expect(isEmployee).to.be.true;
    });

    it("Should prevent non-owner from adding employee", async function () {
      await expect(
        employeeAssignment.connect(user1).assignNewEmployee(employee1.address)
      ).to.be.revertedWith("EmployeeAssignment: caller is not the owner");
    });
  });

  describe("UserReputation", function () {
    beforeEach(async function () {
      // Register user first
      await userRegister.connect(user1).register(
        "User One",
        25
      );
    });

    it("Should start with zero reputation", async function () {
      const myPoint = await reputation.myPoint(user1.address);
      expect(myPoint).to.equal(0);
    });

    it("Should allow setting reputation points configuration", async function () {
      // Set reputation points configuration
      await reputation.connect(owner).setReputationPoints({
        CancelByMe: 10,
        requestCancel: 20,
        respondCancel: 30,
        revision: 40,
        taskAcceptCreator: 50,
        taskAcceptMember: 60,
        deadlineHitCreator: 70,
        deadlineHitMember: 80
      });

      const points = await reputation.reputationPoints();
      expect(points.CancelByMe).to.equal(10);
      expect(points.requestCancel).to.equal(20);
      expect(points.respondCancel).to.equal(30);
      expect(points.revision).to.equal(40);
      expect(points.taskAcceptCreator).to.equal(50);
      expect(points.taskAcceptMember).to.equal(60);
      expect(points.deadlineHitCreator).to.equal(70);
      expect(points.deadlineHitMember).to.equal(80);
    });
  });

  describe("SystemWallet", function () {
    const testAmount = ethers.parseEther("1.0");

    it("Should receive funds", async function () {
      // Send some ETH to the system wallet
      await owner.sendTransaction({
        to: await systemWallet.getAddress(),
        value: testAmount
      });

      // Check wallet balance
      const balance = await ethers.provider.getBalance(await systemWallet.getAddress());
      expect(balance).to.equal(testAmount);
    });

    it("Should allow owner to transfer funds", async function () {
      // First fund the contract
      await owner.sendTransaction({
        to: await systemWallet.getAddress(),
        value: testAmount
      });

      // Get initial balance of user1
      const initialBalance = await ethers.provider.getBalance(user1.address);

      // Transfer funds from system wallet to user1
      await systemWallet.connect(owner).transfer(user1.address, testAmount);

      // Check new balance
      const finalBalance = await ethers.provider.getBalance(user1.address);
      expect(finalBalance - initialBalance).to.equal(testAmount);
    });

    it("Should prevent non-owner from transferring funds", async function () {
      await expect(
        systemWallet.connect(user1).transfer(user2.address, testAmount)
      ).to.be.revertedWith("Not owner");
    });
  });
});