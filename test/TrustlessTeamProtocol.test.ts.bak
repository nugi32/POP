import { expect } from "chai";
import { ethers, upgrades } from "hardhat";
import { Contract } from "ethers";
import { HardhatEthersSigner } from "@nomicfoundation/hardhat-ethers/signers";

// Import contract types
import { EmployeeAssignment } from "../typechain-types/contracts/Owner/employe_assignment.sol/EmployeeAssignment";
import { System_wallet } from "../typechain-types/contracts/system/Wallet.sol/System_wallet";
import { UserRegister } from "../typechain-types/contracts/User/register.sol/UserRegister";
import { UserReputation } from "../typechain-types/contracts/Logic/Reputation.sol/UserReputation";

describe("TrustlessTeamProtocol", function () {
  let userRegister: any;
  let reputation: any;
  let employeeAssignment: any;
  let systemWallet: any;
  let owner: HardhatEthersSigner;
  let user1: HardhatEthersSigner;
  let user2: HardhatEthersSigner;
  let employee1: HardhatEthersSigner;

  // Increase test timeout for deployments
  this.timeout(50000);

  beforeEach(async function () {
    // Get signers
    [owner, user1, user2, employee1] = await ethers.getSigners();

    try {
      // Deploy Employee Assignment first
      const EmployeeAssignmentFactory = await ethers.getContractFactory("EmployeeAssignment", owner);
      employeeAssignment = await upgrades.deployProxy(EmployeeAssignmentFactory, [], {
        initializer: "initialize",
        kind: "uups"
      });
      await employeeAssignment.waitForDeployment();
      const employeeAssignmentAddress = await employeeAssignment.getAddress();

      // Deploy System Wallet with EmployeeAssignment address
      const SystemWalletFactory = await ethers.getContractFactory("System_wallet", owner);
      systemWallet = await upgrades.deployProxy(SystemWalletFactory, [employeeAssignmentAddress], {
        initializer: "initialize",
        kind: "uups"
      });
      await systemWallet.waitForDeployment();
      const systemWalletAddress = await systemWallet.getAddress();

      // Deploy UserRegister with required dependencies
      const UserRegisterFactory = await ethers.getContractFactory("UserRegister", owner);
      userRegister = await upgrades.deployProxy(UserRegisterFactory, [
        employeeAssignmentAddress,
        systemWalletAddress
      ], {
        initializer: "initialize",
        kind: "uups"
      });
      await userRegister.waitForDeployment();
      const userRegisterAddress = await userRegister.getAddress();

      // Deploy UserReputation with UserRegister address
      const ReputationFactory = await ethers.getContractFactory("UserReputation", owner);
      reputation = await upgrades.deployProxy(ReputationFactory, [userRegisterAddress], {
        initializer: "__UserReputation_init",
        kind: "uups"
      });
      await reputation.waitForDeployment();
    } catch (error) {
      console.error("Error during deployment:", error);
      throw error;
    }
  });

  describe("UserRegister", function () {
    it("Should allow user registration", async function () {
      await userRegister.connect(user1).register(
        "User One",
        25
      );

      const isRegistered = await userRegister.isRegistered(user1.address);
      expect(isRegistered).to.be.true;
    });

    it("Should prevent duplicate registration", async function () {
      await userRegister.connect(user1).register(
        "User One",
        25
      );

      await expect(
        userRegister.connect(user1).register(
          "User One Again",
          25
        )
      ).to.be.revertedWith("User already registered");
    });
  });

  describe("EmployeeAssignment", function () {
    it("Should allow owner to add employee", async function () {
      await employeeAssignment.connect(owner).addEmployee(employee1.address, "Employee One");
      const isEmployee = await employeeAssignment.isEmployee(employee1.address);
      expect(isEmployee).to.be.true;
    });

    it("Should prevent non-owner from adding employee", async function () {
      await expect(
        employeeAssignment.connect(user1).addEmployee(employee1.address, "Employee One")
      ).to.be.reverted;
    });
  });

  describe("UserReputation", function () {
    beforeEach(async function () {
      // Register user first
      await userRegister.connect(user1).register(
        "User One",
        25
      );
    });

    it("Should start with zero reputation", async function () {
      const rep = await reputation.getUserReputation(user1.address);
      expect(rep).to.equal(0);
    });

    it("Should allow authorized address to update reputation", async function () {
      // First, set the userRegister as authorized
      await reputation.connect(owner).addAuthorizedContract(await userRegister.getAddress());
      
      // Now try to update reputation through owner
      await reputation.connect(owner).updateReputation(user1.address, 100);
      
      const rep = await reputation.getUserReputation(user1.address);
      expect(rep).to.equal(100);
    });
  });

  describe("SystemWallet", function () {
    const testAmount = ethers.parseEther("1.0");

    it("Should be initialized", async function () {
      expect(await systemWallet.initialized()).to.be.true;
    });

    it("Should receive funds", async function () {
      // Send some ETH to the system wallet
      await owner.sendTransaction({
        to: await systemWallet.getAddress(),
        value: testAmount
      });

      // Check wallet balance
      const balance = await ethers.provider.getBalance(await systemWallet.getAddress());
      expect(balance).to.equal(testAmount);
    });

    it("Should allow owner to transfer funds", async function () {
      // First fund the contract
      await owner.sendTransaction({
        to: await systemWallet.getAddress(),
        value: testAmount
      });

      // Get initial balance of user1
      const initialBalance = await ethers.provider.getBalance(user1.address);

      // Transfer funds from system wallet to user1
      await systemWallet.connect(owner).transfer(user1.address, testAmount);

      // Check new balance
      const finalBalance = await ethers.provider.getBalance(user1.address);
      expect(finalBalance - initialBalance).to.equal(testAmount);
    });

    it("Should prevent non-owner from transferring funds", async function () {
      await expect(
        systemWallet.connect(user1).transfer(user2.address, testAmount)
      ).to.be.reverted;
    });
  });
});
  });

  describe("SystemWallet", function () {
    it("Should initialize correctly", async function () {
      const initialized = await systemWallet.initialized();
      expect(initialized).to.be.true;
    });

    it("Should allow owner to set transaction fee", async function () {
      await systemWallet.connect(owner).setTransactionFee(100); // 1%
      const fee = await systemWallet.transactionFee();
      expect(fee).to.equal(100);
    });
  });
});
